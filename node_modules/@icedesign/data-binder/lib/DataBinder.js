"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dataBinder;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _message = _interopRequireDefault(require("@alifd/next/lib/message"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _axios = _interopRequireDefault(require("axios"));

var _pureRenderDecorator = _interopRequireDefault(require("pure-render-decorator"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

/* eslint-disable no-underscore-dangle, no-nested-ternary */

/**
 * 初始化对象的加载状态，错误状态等，并且该值不能枚举
 * @param {Object|Array} target  目标对象
 */
function initializeRequestStatus(target) {
  var requestStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    __loading: false,
    __error: null
  };
  Object.defineProperty(target, '__loading', {
    value: typeof requestStatus.__loading !== 'undefined' ? requestStatus.__loading : target.__loading !== 'undefined' ? target.__loading : false,
    writable: true,
    enumerable: false,
    configurable: false
  });
  Object.defineProperty(target, '__error', {
    value: typeof requestStatus.__error !== 'undefined' ? requestStatus.__error : target.__error !== 'undefined' ? target.__error : null,
    writable: true,
    configurable: false,
    enumerable: false
  });
  return target;
}
/**
 * merge array use override
 */


var overwriteMerge = function overwriteMerge(destArray, sourceArray) {
  return sourceArray;
};

var defaultOpts = {
  requestClient: _axios.default,
  arrayMerge: overwriteMerge
};
/**
 * DataBinder 的 HOC 创建函数，预先做一些数据整理
 *
 * @param  {Object} sourceConfig 为各个模块的 DataSource 配置，详情参见 README.md 和 Demo
 * @return {function}
 */

function dataBinder(sourceConfig) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  opts.__proto__ = defaultOpts; // apply default opts

  var requestOptions = {}; // 请求参数 map 数据结构
  // 请求数据 map 数据结构

  var defaultBindingDatas = initializeRequestStatus({}); // initial merge option
  // ref: https://www.npmjs.com/package/deepmerge

  var mergeOption = {
    arrayMerge: opts.arrayMerge
  }; // 根据传入数据进行初始化

  Object.keys(sourceConfig).forEach(function (dataSourceKey) {
    var _sourceConfig$dataSou = sourceConfig[dataSourceKey],
        _sourceConfig$dataSou2 = _sourceConfig$dataSou.defaultBindingData,
        defaultBindingData = _sourceConfig$dataSou2 === void 0 ? {} : _sourceConfig$dataSou2,
        others = (0, _objectWithoutProperties2.default)(_sourceConfig$dataSou, ["defaultBindingData"]);
    defaultBindingDatas[dataSourceKey] = initializeRequestStatus(defaultBindingData);
    requestOptions[dataSourceKey] = others;
  });
  /**
   * Core HOC 函数
   *
   * @param  {ReactElement} WrappedComponent 被包裹的 React Element
   * @return {ReactElement}                  IceDataBinderWrapper React Element
   */

  return function dataBinderHOC(WrappedComponent) {
    var _class, _class2, _temp;

    return (0, _pureRenderDecorator.default)(_class = (_temp = _class2 =
    /*#__PURE__*/
    function (_Component) {
      (0, _inherits2.default)(IceDataBinderWrapper, _Component);

      function IceDataBinderWrapper(props) {
        var _this;

        (0, _classCallCheck2.default)(this, IceDataBinderWrapper);
        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IceDataBinderWrapper).call(this, props)); // state 默认包含所有的 DataSource 中的 defaultBindingData 数据

        _this.updateStateWithDataSource = function (dataSourceKey, originDatas, newData, requestStatus) {
          // 变成数据的请求状态
          initializeRequestStatus(originDatas[dataSourceKey], requestStatus);
          var tmpObj = {};

          if (newData) {
            if (Array.isArray(originDatas[dataSourceKey])) {
              tmpObj[dataSourceKey] = initializeRequestStatus(newData, requestStatus);
            } else {
              // Object 是一个浅拷贝操作，保留原数据的其他一级字段
              tmpObj[dataSourceKey] = initializeRequestStatus((0, _objectSpread2.default)({}, originDatas[dataSourceKey], newData), requestStatus);
            }
          }

          _this.setState((0, _objectSpread2.default)({}, _this.state, tmpObj, requestStatus));
        };

        _this.updateBindingData = function (dataSourceKey) {
          var newDataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var callback = arguments.length > 2 ? arguments[2] : undefined;

          if (!dataSourceKey && typeof dataSourceKey !== 'string') {
            // eslint-disable-next-line no-console
            console.error('必须指明一个 dataSourceKey，并且值类型为 String。');
            return;
          }

          var newRequestOptions = (0, _deepmerge.default)( // 参数每次跟初始化的配置进行 merge
          requestOptions[dataSourceKey], newDataSource, mergeOption); // 如果更新时同时附带 defaultBindingData 则先同步更新一次数据，再请求更新
          // 没有 url 配置走同步修改逻辑，只修改 DataSource defaultBindingData 的数据，不进行异步请求

          if (!newRequestOptions.url) {
            if (newDataSource.defaultBindingData) {
              _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, newDataSource.defaultBindingData);
            } else {
              // eslint-disable-next-line no-console
              console.error('要更新的 DataSource 必须要有一个 url 或者 defaultBindingData 配置。');
            }

            return;
          } // 这里只需要改变模块的 __loading 属性，不涉及数据 merge
          // 因此要获取当前最新的 state 否则界面会突然切换回默认数据，然后再生效


          _this.updateStateWithDataSource(dataSourceKey, _this.state, newDataSource.defaultBindingData, {
            __loading: true
          });

          var customSuccess = newRequestOptions.success;
          var customError = newRequestOptions.error;

          var defaultErrorCallback = function defaultErrorCallback() {
            _message.default.error('网络问题，请稍后重试！');
          };

          opts.requestClient((0, _objectSpread2.default)({}, newRequestOptions)) // network error
          .catch(function (err) {
            // eslint-disable-next-line
            var __error = {
              message: err.message || '网络问题，请稍后重试！'
            };

            _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, null, {
              __loading: false,
              __error: __error
            });

            if (customError) {
              customError(err.response, defaultErrorCallback, err);
            } else {
              // 如果没有自定义回调，那么就执行默认的 callback 提示
              defaultErrorCallback();
            }

            if (typeof callback === 'function') {
              callback(err.response, err);
            }
          }).then(function (res) {
            if (!res) {
              // 接口报错
              return;
            }

            var responseHandler = function responseHandler(responseData, originResponse) {
              if (!responseData.data) {
                // eslint-disable-next-line no-console
                console.error('警告：接口必须返回一个 data 字段作为新数据！如果接口无法改动，请配置 responseFormatter 进行数据格式调整！');
                responseData.data = {};
              } // eslint-disable-next-line


              var __error = null; // 兼容 status: "SUCCESS" 和 success: true 的情况

              if (responseData.status === 'SUCCESS' || responseData.success) {
                var defaultCallback = function defaultCallback() {
                  if (responseData.message) {
                    _message.default.success(responseData.message);
                  }
                };

                if (customSuccess) {
                  // 传递 defaultCallback 第二个参数是为了让用户可以在现有默认逻辑上执行其他
                  // 自定义逻辑
                  customSuccess(responseData, defaultCallback, originResponse);
                } else {
                  defaultCallback();
                }
              } else {
                __error = {
                  message: responseData.message
                };

                var _defaultCallback = function _defaultCallback() {
                  if (responseData.message) {
                    _message.default.error(responseData.message);
                  }
                }; // 这里的 success 是请求成功的意思，并不表示业务逻辑执行成功
                // TODO: 设计上不太合理，应该触发 customError 然后通过参数区分网络错误还是状态码错误


                if (customSuccess) {
                  customSuccess(responseData, _defaultCallback, originResponse);
                } else {
                  _defaultCallback();
                }
              } // 更新数据重新渲染，不确定失败的情况下是否要更新
              // 但是失败可能需要某些状态来显示报错信息，所以保留了


              _this.updateStateWithDataSource(dataSourceKey, defaultBindingDatas, responseData.data, {
                __loading: false,
                __error: __error
              });
            };

            userFormatterIfExist(newRequestOptions.responseFormatter, responseHandler, res.data, res);

            if (typeof callback === 'function') {
              callback(res.data, res);
            }
          });
        };

        _this.getDataSource = function (dataSourceKey) {
          return sourceConfig[dataSourceKey];
        };

        _this.state = (0, _objectSpread2.default)({}, defaultBindingDatas);
        return _this;
      }
      /**
       * 更新某个 DataSource 的数据，混合原始数据、新数据来更新
       *
       * @private
       * @param  {String} dataSourceKey 要更新的 DataSource key
       * @param  {Object} originDatas   等待被更新的所有 DataSource 数据
       * @param  {Object} newData       新的 DataSource 数据
       * @return undefined
       */


      (0, _createClass2.default)(IceDataBinderWrapper, [{
        key: "render",
        value: function render() {
          return _react.default.createElement(WrappedComponent, (0, _extends2.default)({}, this.props, {
            getDataSource: this.getDataSource,
            updateBindingData: this.updateBindingData,
            bindingData: this.state,
            updateStateWithDataSource: this.updateStateWithDataSource
          }));
        }
      }]);
      return IceDataBinderWrapper;
    }(_react.Component), _class2.displayName = "IceDataBinderWrapper(".concat(getDisplayName(WrappedComponent), ")"), _temp)) || _class;
  };
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

function userFormatterIfExist(funca, funcb, responseData, originResponse) {
  if (funca) {
    funca(funcb, responseData, originResponse);
  } else {
    funcb(responseData, originResponse);
  }
}